It is clear from these results that, at the very least, time randomization increases the exploitation cost for some concurrency bugs.
%\textbf{T3} appears to be more effective than the other two transformations.
%One possible explanation for this is that \textbf{T3}
Then the major argument against employing it universally becomes performance overhead.
While overheads on effective randomizations were unacceptably high using the NOP injection implementations tested here (at least 12x for \textbf{T1} and at least 5x for \textbf{T3}), it is not clear that significant overhead is necessary for time randomization in general.
Part of the effect of time randomization via NOP injection is to modify thread interleavings by signaling with NOPs to the scheduler that another thread can be scheduled.
The randomization between and among threads achieved here with NOP injection could conceivably be achieved directly in the scheduler via random synchronization schedules.
By modifying the scheduler directly, it may be possible to obtain the same benefits shown here with minimal overhead.

Alternatively, a more complicated heuristic could be applied to the NOP insertion implementations investigated here.
More specifically, for each randomization, measurements could be taken of the extent to which relative thread timing has been randomized, and of some performance metric.
These measurements could be used to decide whether to keep a specific randomization or generate a new one, as well as to calibrate randomization parameters like max delay in this work.